<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title updated -->
    <title>For SAP Item Photo - 4.1 (ZIP Output)</title>
    <!-- *** Include JSZip library via CDN *** -->
    <!-- Make sure jszip.min.js is in the 'dist' folder or update path -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            width: 750px; /* Slightly wider for new option */
        }
        .drop-zone {
            border: 2px dashed #ccc;
            padding: 20px;
            margin: 10px 0;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        .drop-zone.dragover {
            border-color: #007bff;
            background-color: #e6f0ff;
        }
        input[type="file"] {
            margin: 10px 0;
        }
        input[type="text"] {
            padding: 5px;
            margin: 5px 0;
        }
        canvas.preview {
            max-width: 80px;
            max-height: 80px;
            margin: 5px;
            border: 1px solid #ccc;
            flex-shrink: 0;
        }
        #status {
            margin-top: 10px;
            color: #555;
            min-height: 1.2em;
        }
        #fileList {
            margin-top: 10px;
            text-align: left;
            max-height: 350px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 5px;
        }
        .file-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            padding: 8px 5px;
            border-bottom: 1px solid #eee;
            gap: 6px; /* Adjusted gap */
        }
        .file-item:last-child {
            border-bottom: none;
        }
        .file-item span { /* File name */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 80px; /* Adjusted width */
            max-width: 150px; /* Adjusted width */
            flex-shrink: 1;
            font-size: 0.9em;
        }
        .file-item input[type="text"] { /* Output name */
            flex: 1 1 auto;
            min-width: 80px; /* Adjusted width */
            margin-left: 5px;
        }
        .file-item label {
             white-space: nowrap;
             font-size: 0.9em;
             margin-left: 4px; /* Slightly reduce margin */
             display: flex;
             align-items: center;
             cursor: pointer; /* Make label clickable */
        }
        .file-item input[type="checkbox"] {
            margin-right: 3px;
            vertical-align: middle; /* Align checkbox better */
        }
        button {
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 15px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .error-message {
            color: red;
            font-weight: bold;
        }
        .bg-options { /* Container for background options */
            display: flex;
            align-items: center;
            gap: 5px; /* Space between background options */
            border-left: 1px solid #ddd; /* Separator */
            padding-left: 8px; /* Space after separator */
            margin-left: 5px; /* Space before separator */
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>For SAP Item Photo - 4.1</h2>
        <!-- Updated description -->
        <h4>自動調整大小為600x600並轉為灰階(PNG)，可選背景處理(預設填白)。處理後打包成ZIP下載。</h4>
        <div id="dropZone" class="drop-zone">
            拖放圖片到此處或點擊選擇檔案 (可批量)
            <input type="file" id="imageInput" accept="image/*" multiple style="display: none;">
        </div>
        <div id="fileList"></div>
        <button id="processButton" style="display: none;" disabled>開始處理並打包 ZIP</button>
        <div id="status">等待上傳...</div>
        <canvas id="canvas" style="display: none;"></canvas>
    </div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const imageInput = document.getElementById('imageInput');
        const fileList = document.getElementById('fileList');
        const processButton = document.getElementById('processButton');
        const status = document.getElementById('status');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let filesToProcess = [];
        let imageDataArray = [];
        const MAX_FILES = 100;

        // Drag & Drop Events (remain the same)
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('dragover'); });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        dropZone.addEventListener('click', () => { imageInput.click(); });
        imageInput.addEventListener('change', () => {
            handleFiles(imageInput.files);
            imageInput.value = ''; // Clear input for re-selection
        });

        function handleFiles(files) {
            status.classList.remove('error-message');
            status.style.color = '#555';

            if (files.length > MAX_FILES) {
                status.textContent = `錯誤：一次最多只能處理 ${MAX_FILES} 個檔案，您選擇了 ${files.length} 個。`;
                status.classList.add('error-message');
                resetPartialUI();
                return;
            }

             const potentialFiles = Array.from(files).filter(file => {
                const isImage = file.type.startsWith('image/');
                if (!isImage) console.warn(`Skipping non-image file: ${file.name}`);
                return isImage;
            });

            if (potentialFiles.length === 0 && files.length > 0) {
                 status.textContent = '選取的檔案中沒有有效的圖片格式。';
                 status.classList.add('error-message');
                 resetPartialUI();
                 return;
            } else if (potentialFiles.length === 0) {
                 status.textContent = '未選擇有效圖片檔案。';
                 resetPartialUI();
                 return;
            }

            filesToProcess = potentialFiles;
            imageDataArray = new Array(filesToProcess.length);

            status.textContent = `已選擇 ${filesToProcess.length} 個圖片檔案。請確認檔名與背景選項。`;
            fileList.innerHTML = ''; // Clear previous list

            let loadPromises = filesToProcess.map((file, index) => {
                return new Promise((resolve, reject) => {
                    const div = document.createElement('div');
                    div.className = 'file-item';
                    div.id = `file-item-${index}`;
                    const previewCanvas = document.createElement('canvas');
                    previewCanvas.className = 'preview';
                    previewCanvas.id = `preview-${index}`;
                    const defaultName = file.name.split('.').slice(0, -1).join('.') || file.name;

                    // *** UPDATED: Add "Fill White" checkbox and group options ***
                    div.innerHTML = `
                        <span title="${file.name}">${file.name}</span>
                        <input type="text" value="${defaultName}" data-index="${index}" title="輸出檔名 (不含.png)">
                        <div class="bg-options" data-index="${index}">
                            <label title="將背景填充為白色 (預設)"><input type="checkbox" class="fill-white-bg" data-index="${index}" checked> 填白</label>
                            <label title="使用圖片主要顏色填充透明區域"><input type="checkbox" class="fill-dominant-bg" data-index="${index}"> 填充</label>
                            <label title="嘗試將圖片主要背景色變為透明"><input type="checkbox" class="remove-bg" data-index="${index}"> 移除</label>
                        </div>
                    `;
                    div.prepend(previewCanvas);
                    fileList.appendChild(div);

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            imageDataArray[index] = { img, file };
                            updatePreview(index); // Update preview after image loads
                            resolve();
                        };
                        img.onerror = () => {
                            console.error(`Failed to load image: ${file.name}`);
                            markItemAsError(index, '無法載入圖片');
                            reject(new Error(`Failed to load ${file.name}`));
                        };
                        try { img.src = event.target.result; } catch (e) { reject(e); }
                    };
                    reader.onerror = () => {
                        console.error(`Failed to read file: ${file.name}`);
                        markItemAsError(index, '無法讀取檔案');
                        reject(new Error(`Failed to read ${file.name}`));
                    };
                    reader.readAsDataURL(file);

                    // *** NEW: Checkbox exclusivity logic ***
                    const bgOptionsDiv = div.querySelector('.bg-options');
                    const fillWhiteCheckbox = bgOptionsDiv.querySelector('.fill-white-bg');
                    const fillDominantCheckbox = bgOptionsDiv.querySelector('.fill-dominant-bg');
                    const removeCheckbox = bgOptionsDiv.querySelector('.remove-bg');
                    const checkboxes = [fillWhiteCheckbox, fillDominantCheckbox, removeCheckbox];

                    checkboxes.forEach(checkbox => {
                        checkbox.addEventListener('change', (e) => {
                            const currentCheckbox = e.target;
                            const currentIndex = currentCheckbox.dataset.index;
                            if (currentCheckbox.checked) {
                                // Uncheck other checkboxes in the same group
                                checkboxes.forEach(cb => {
                                    if (cb !== currentCheckbox && cb.dataset.index === currentIndex) {
                                        cb.checked = false;
                                    }
                                });
                            } else {
                                // If user unchecks the currently checked one, re-check the default (Fill White)
                                const isAnyChecked = checkboxes.some(cb => cb.checked);
                                if (!isAnyChecked) {
                                    fillWhiteCheckbox.checked = true;
                                }
                            }
                            updatePreview(currentIndex); // Update preview on change
                        });
                    });
                }); // End of new Promise
            }); // End of map

            // Wait for all images to attempt loading
            Promise.allSettled(loadPromises).then(results => {
                const loadedSuccessfully = results.some(r => r.status === 'fulfilled');
                const failedCount = results.filter(r => r.status === 'rejected').length;

                 if (failedCount > 0) {
                    status.textContent += ` (${failedCount} 個檔案載入失敗)`;
                    status.classList.add('error-message');
                 }
                if (loadedSuccessfully) {
                    processButton.style.display = 'block';
                    processButton.disabled = false;
                } else {
                     status.textContent = '所有圖片檔案均無法載入。';
                     status.classList.add('error-message');
                     resetPartialUI();
                }
            });
        }

        function markItemAsError(index, message) {
             const itemDiv = document.getElementById(`file-item-${index}`);
             if (itemDiv) {
                 itemDiv.style.opacity = '0.5';
                 itemDiv.style.borderLeft = '3px solid red';
                 itemDiv.title = message;
                 // Disable checkboxes for errored items
                 itemDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.disabled = true);
             }
             const previewCanvas = document.getElementById(`preview-${index}`);
             if (previewCanvas) {
                 const prevCtx = previewCanvas.getContext('2d');
                 prevCtx.fillStyle = 'rgba(255, 0, 0, 0.1)';
                 prevCtx.fillRect(0,0, previewCanvas.width, previewCanvas.height);
             }
        }

         function resetPartialUI() {
            fileList.innerHTML = '';
            processButton.style.display = 'none';
            processButton.disabled = true;
            imageDataArray = [];
         }

        function updatePreview(index) {
            if (!imageDataArray[index] || !imageDataArray[index].img) return;
            try {
                const { img } = imageDataArray[index];
                const previewCanvas = document.getElementById(`preview-${index}`);
                if (!previewCanvas) return;
                const previewCtx = previewCanvas.getContext('2d');
                const previewSize = 80;
                previewCanvas.width = previewSize;
                previewCanvas.height = previewSize;

                let scale = Math.min(previewSize / img.width, previewSize / img.height);
                let newWidth = img.width * scale;
                let newHeight = img.height * scale;
                let offsetX = (previewSize - newWidth) / 2;
                let offsetY = (previewSize - newHeight) / 2;

                previewCtx.clearRect(0, 0, previewSize, previewSize);

                // --- Apply temporary effects for preview ---
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = previewSize;
                tempCanvas.height = previewSize;
                const tempCtx = tempCanvas.getContext('2d');

                // Get checkbox states for this item
                const fillWhiteCheckbox = document.querySelector(`.fill-white-bg[data-index="${index}"]`);
                const fillDominantCheckbox = document.querySelector(`.fill-dominant-bg[data-index="${index}"]`);
                const removeBgCheckbox = document.querySelector(`.remove-bg[data-index="${index}"]`);

                // --- Preview Initial Background ---
                tempCtx.clearRect(0, 0, previewSize, previewSize); // Start fresh
                if (fillWhiteCheckbox?.checked) {
                    tempCtx.fillStyle = 'white';
                    tempCtx.fillRect(0, 0, previewSize, previewSize);
                }
                // If removing bg, leave transparent initially for checkerboard effect later
                // If filling dominant, also leave transparent initially, fill after drawing

                // Draw the scaled image onto the temp canvas
                tempCtx.drawImage(img, offsetX, offsetY, newWidth, newHeight);

                // --- Preview Post-Draw Effects ---
                let showCheckerboard = false;
                if (removeBgCheckbox?.checked) {
                    let bgColor = getBackgroundColor(tempCtx, previewSize, previewSize);
                    if (bgColor) removeBackground(tempCtx, previewSize, previewSize, bgColor);
                    showCheckerboard = true; // Indicate transparency needed
                } else if (fillDominantCheckbox?.checked) {
                    let bgColor = getBackgroundColor(tempCtx, previewSize, previewSize);
                    // Fill only transparent areas *after* drawing image
                    if (bgColor) fillTransparentBackground(tempCtx, previewSize, previewSize, bgColor);
                 } else if (!fillWhiteCheckbox?.checked) {
                     // If *nothing* is checked (shouldn't happen with the new logic, but as fallback)
                     // or if fillDominant was chosen but couldn't find color, ensure white background
                     const tempData = tempCtx.getImageData(0,0,previewSize, previewSize);
                     const data = tempData.data;
                     for(let i=0; i<data.length; i+=4) {
                         if(data[i+3] < 255) { // If transparent
                             data[i] = 255; data[i+1] = 255; data[i+2] = 255; data[i+3] = 255;
                         }
                     }
                     tempCtx.putImageData(tempData, 0,0);
                 }


                // Apply grayscale preview effect on temp canvas
                const tempImageData = tempCtx.getImageData(0, 0, previewSize, previewSize);
                const tempData = tempImageData.data;
                for (let i = 0; i < tempData.length; i += 4) {
                    const gray = 0.2126 * tempData[i] + 0.7152 * tempData[i + 1] + 0.0722 * tempData[i + 2];
                    tempData[i] = tempData[i + 1] = tempData[i + 2] = gray;
                }
                tempCtx.putImageData(tempImageData, 0, 0);

                // Draw the final preview from the temp canvas back to the visible preview canvas
                previewCtx.clearRect(0, 0, previewSize, previewSize); // Clear original

                // Draw checkerboard *behind* the processed image if removeBg is checked
                if (showCheckerboard) {
                    previewCtx.fillStyle = '#eee'; previewCtx.fillRect(0,0,previewSize/2,previewSize/2); previewCtx.fillRect(previewSize/2,previewSize/2,previewSize/2,previewSize/2);
                    previewCtx.fillStyle = '#ccc'; previewCtx.fillRect(previewSize/2,0,previewSize/2,previewSize/2); previewCtx.fillRect(0,previewSize/2,previewSize/2,previewSize/2);
                }
                previewCtx.drawImage(tempCanvas, 0, 0); // Draw processed preview

            } catch (error) {
                console.error(`Error updating preview for index ${index}:`, error);
                markItemAsError(index, '預覽時發生錯誤');
            }
        }

        // Process Button Click
        processButton.addEventListener('click', async () => {
            if (filesToProcess.length === 0 || imageDataArray.filter(Boolean).length === 0) {
                status.textContent = '沒有可處理的圖片檔案 (或圖片載入失敗)。';
                 status.classList.add('error-message');
                return;
            }

            status.classList.remove('error-message');
            processButton.disabled = true;
            processButton.textContent = '處理中...';

            // Capture custom names and background choices
            const customNames = filesToProcess.map((_, index) => {
                const input = fileList.querySelector(`input[type="text"][data-index="${index}"]`);
                return input ? input.value.trim() : `processed_${index + 1}`;
            });
            // *** UPDATED: Capture all three choices ***
            const fillWhiteChoices = filesToProcess.map((_, index) => fileList.querySelector(`.fill-white-bg[data-index="${index}"]`)?.checked ?? true); // Default true if query fails
            const fillDominantChoices = filesToProcess.map((_, index) => fileList.querySelector(`.fill-dominant-bg[data-index="${index}"]`)?.checked ?? false);
            const removeBgChoices = filesToProcess.map((_, index) => fileList.querySelector(`.remove-bg[data-index="${index}"]`)?.checked ?? false);

            // Call the zip function with all choices
            await processFilesAndZip(filesToProcess, customNames, fillWhiteChoices, fillDominantChoices, removeBgChoices);

            processButton.disabled = false;
            processButton.textContent = '開始處理並打包 ZIP';
        });

        // *** UPDATED Function signature and logic ***
        async function processFilesAndZip(files, customNames, fillWhiteChoices, fillDominantChoices, removeBgChoices) {
            const processedBlobs = [];
            const totalFiles = files.length;
            let processedCount = 0;
            let errorCount = 0;

            status.textContent = `正在處理 ${totalFiles} 個檔案... (0%)`;

            for (let index = 0; index < totalFiles; index++) {
                const file = files[index];
                const imgData = imageDataArray[index];

                if (!imgData || !imgData.img) {
                    console.warn(`Skipping ${file.name}: Image data not loaded.`);
                    errorCount++;
                    processedCount++;
                    updateProgress(processedCount, totalFiles);
                    markItemAsError(index, `跳過: 圖片未載入`); // Mark as error in UI
                    continue;
                }

                const img = imgData.img;
                const customName = customNames[index];
                // Get the choices for this specific index
                const fillWhite = fillWhiteChoices[index];
                const fillDominant = fillDominantChoices[index];
                const removeBg = removeBgChoices[index];

                const finalName = customName || file.name.split('.').slice(0, -1).join('.') || `image_${index + 1}`;
                const outputFileName = `${finalName}.png`;

                try {
                    canvas.width = 600;
                    canvas.height = 600;
                    ctx.clearRect(0, 0, canvas.width, canvas.height); // Start clean

                    let scale = Math.min(600 / img.width, 600 / img.height);
                    let newWidth = img.width * scale;
                    let newHeight = img.height * scale;
                    let offsetX = (600 - newWidth) / 2;
                    let offsetY = (600 - newHeight) / 2;

                    // --- Background Handling (Before Draw) ---
                    if (fillWhite) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    // If removeBg or fillDominant, leave transparent for now

                    // --- Draw Image ---
                    ctx.drawImage(img, offsetX, offsetY, newWidth, newHeight);

                    // --- Background Handling (Post Draw) ---
                    if (removeBg) {
                        let bgColor = getBackgroundColor(ctx, canvas.width, canvas.height);
                        if (bgColor) removeBackground(ctx, canvas.width, canvas.height, bgColor);
                    } else if (fillDominant) {
                        let dominantColor = getBackgroundColor(ctx, canvas.width, canvas.height);
                        if (dominantColor) fillTransparentBackground(ctx, canvas.width, canvas.height, dominantColor);
                    } else if (!fillWhite) {
                        // Fallback / Default: Ensure fully white background if no other option applied
                        // This covers cases where the image had transparency but wasn't explicitly filled white/dominant or removed
                        const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = currentImageData.data;
                        for (let i = 0; i < data.length; i += 4) {
                             if (data[i + 3] < 255) { // If not fully opaque, make it white
                                data[i] = 255; data[i + 1] = 255; data[i + 2] = 255; data[i + 3] = 255;
                            }
                        }
                        ctx.putImageData(currentImageData, 0, 0);
                    }

                    // --- Grayscale (After all background processing) ---
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
                        data[i] = data[i + 1] = data[i + 2] = gray;
                        // Ensure alpha is 255 unless removeBg was chosen (removeBackground sets alpha to 0)
                        if (!removeBg) data[i+3] = 255;
                    }
                    ctx.putImageData(imageData, 0, 0);

                    // Get Blob
                    const blob = await new Promise((resolve) => { canvas.toBlob(resolve, 'image/png'); });

                    if (blob) {
                        processedBlobs.push({ filename: outputFileName, blob: blob });
                        // Mark success visually
                        const itemDiv = document.getElementById(`file-item-${index}`);
                        if(itemDiv) itemDiv.style.borderLeft = '3px solid green';
                    } else {
                        throw new Error("Canvas toBlob failed.");
                    }

                    processedCount++;
                    updateProgress(processedCount, totalFiles);

                } catch (error) {
                    console.error(`Error processing file ${file.name}:`, error);
                    errorCount++;
                    processedCount++;
                    updateProgress(processedCount, totalFiles);
                    markItemAsError(index, `處理失敗: ${error.message.substring(0, 50)}`);
                }
            } // End of loop

            // --- ZIP Generation ---
            if (processedBlobs.length > 0) {
                status.textContent = `處理完成 (${totalFiles - errorCount} 成功 / ${errorCount} 失敗)。正在產生 ZIP 檔案...`;
                try {
                    const zip = new JSZip();
                    processedBlobs.forEach(({ filename, blob }) => {
                        zip.file(filename, blob);
                    });

                    const zipBlob = await zip.generateAsync(
                        { type: "blob", compression: "DEFLATE", compressionOptions: { level: 6 } },
                        (metadata) => { status.textContent = `正在壓縮檔案... ${metadata.percent.toFixed(0)}%`; }
                    );

                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(zipBlob);
                    link.download = `sap_item_photos_${Date.now()}.zip`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);

                    status.textContent = `ZIP 檔案 '${link.download}' 已產生並開始下載 (${processedBlobs.length} 個檔案)。`;

                } catch (zipError) {
                    console.error('Error generating ZIP file:', zipError);
                    status.textContent = '產生 ZIP 檔案時發生錯誤。';
                    status.classList.add('error-message');
                }
            } else if (errorCount === totalFiles) {
                 status.textContent = '所有檔案處理失敗，無法產生 ZIP 檔案。';
                 status.classList.add('error-message');
            } else {
                 status.textContent = '沒有成功處理的檔案可供打包。';
                 status.classList.add('error-message');
            }
             // Reset UI fully after processing
             resetUI();
        }


        function updateProgress(completed, total) {
            const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
            status.textContent = `正在處理 ${total} 個檔案... (${percentage}%) - 已完成 ${completed}/${total}`;
        }

         function resetUI() {
            imageInput.value = '';
            filesToProcess = [];
            imageDataArray = [];
            fileList.innerHTML = '';
            processButton.style.display = 'none';
            processButton.disabled = true;
            processButton.textContent = '開始處理並打包 ZIP';
            // Reset status after a short delay
            setTimeout(() => {
                if (!processButton.disabled) { // Only reset if not actively processing again
                   status.textContent = '等待上傳...';
                   status.classList.remove('error-message');
                }
            }, 5000);
         }

        // --- Background Processing Functions ---
        // (kMeansClustering, getBackgroundColor, fillTransparentBackground, removeBackground)
        // These functions remain the same as in your provided code.
        // Ensure they are included below this point.

        // Placeholder for required helper functions (ensure these are present and correct)
        function kMeansClustering(pixels, k = 3, maxIterations = 10) {
             if (!pixels || pixels.length === 0) return null;
             try {
                 // Limit sample size for performance
                 const sampleSize = Math.min(pixels.length, 300); // Reduced sample size further
                 const samplePixels = [];
                 const step = Math.max(1, Math.floor(pixels.length / sampleSize));
                 for(let i = 0; i < pixels.length; i += step) {
                    samplePixels.push(pixels[i]);
                    if(samplePixels.length >= sampleSize) break;
                 }

                 if (samplePixels.length === 0) return null; // No pixels to sample

                 // Initialize centroids using a basic seeding (first k distinct pixels or random)
                 let centroids = [];
                 let usedIndices = new Set();
                 for(let i = 0; i < samplePixels.length && centroids.length < k; ++i) {
                     // Simple check for distinctness (can be improved)
                     const pixelStr = samplePixels[i].join(',');
                     if(!usedIndices.has(pixelStr)) {
                        centroids.push([...samplePixels[i]]);
                        usedIndices.add(pixelStr);
                     }
                 }
                 // Fill remaining centroids randomly if not enough distinct ones found
                 while(centroids.length < k && samplePixels.length > 0) {
                     centroids.push([...samplePixels[Math.floor(Math.random() * samplePixels.length)]]);
                 }
                 if(centroids.length === 0) return null; // Cannot proceed without centroids


                 let clusters = new Array(samplePixels.length); // Store index of centroid for each pixel
                 for (let iteration = 0; iteration < maxIterations; iteration++) {
                     let changed = false;
                     // Assign pixels to nearest centroid
                     for (let i = 0; i < samplePixels.length; i++) {
                         let minDistanceSq = Infinity;
                         let clusterIndex = -1;
                         for (let j = 0; j < centroids.length; j++) {
                             const distSq = (samplePixels[i][0] - centroids[j][0])**2 + (samplePixels[i][1] - centroids[j][1])**2 + (samplePixels[i][2] - centroids[j][2])**2;
                             if (distSq < minDistanceSq) {
                                 minDistanceSq = distSq;
                                 clusterIndex = j;
                             }
                         }
                         if (clusters[i] !== clusterIndex) {
                             clusters[i] = clusterIndex;
                             changed = true;
                         }
                     }

                     if (!changed && iteration > 0) break; // Converged

                     // Recalculate centroids
                     let counts = new Array(centroids.length).fill(0);
                     let newCentroids = Array.from({ length: centroids.length }, () => [0, 0, 0]);
                     for (let i = 0; i < samplePixels.length; i++) {
                         const clusterIdx = clusters[i];
                         if (clusterIdx !== undefined && clusterIdx >= 0 && clusterIdx < centroids.length) {
                             newCentroids[clusterIdx][0] += samplePixels[i][0];
                             newCentroids[clusterIdx][1] += samplePixels[i][1];
                             newCentroids[clusterIdx][2] += samplePixels[i][2];
                             counts[clusterIdx]++;
                         }
                     }

                     for (let j = 0; j < centroids.length; j++) {
                         if (counts[j] > 0) {
                             centroids[j] = [
                                 Math.round(newCentroids[j][0] / counts[j]),
                                 Math.round(newCentroids[j][1] / counts[j]),
                                 Math.round(newCentroids[j][2] / counts[j])
                             ];
                         } else if (samplePixels.length > 0){
                             // Reinitialize empty cluster centroid randomly
                             centroids[j] = [...samplePixels[Math.floor(Math.random() * samplePixels.length)]];
                             // Consider more robust re-initialization if needed
                         }
                     }
                 } // End iterations

                 // Determine the dominant cluster (most pixels assigned)
                 let clusterCounts = new Array(centroids.length).fill(0);
                 clusters.forEach(cIdx => { if (cIdx !== undefined && cIdx >=0 && cIdx < centroids.length) clusterCounts[cIdx]++; });

                 let maxClusterIndex = 0;
                 for (let i = 1; i < centroids.length; i++) {
                     if (clusterCounts[i] > clusterCounts[maxClusterIndex]) {
                         maxClusterIndex = i;
                     }
                 }

                 // Return the color of the dominant centroid
                 return centroids[maxClusterIndex] ? { r: centroids[maxClusterIndex][0], g: centroids[maxClusterIndex][1], b: centroids[maxClusterIndex][2] } : null;

             } catch (error) { console.error('Error in kMeansClustering:', error); return null; }
        }


        function getBackgroundColor(ctx, width, height) {
            try {
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                const borderPixels = [];
                const sampleDist = 5; // Sample pixels near the border

                // Sample border pixels (top, bottom, left, right)
                for(let x = 0; x < width; x+= sampleDist) {
                    let idxTop = (0 * width + x) * 4;
                    let idxBottom = ((height - 1) * width + x) * 4;
                    if(data[idxTop + 3] === 255) borderPixels.push([data[idxTop], data[idxTop+1], data[idxTop+2]]);
                    if(data[idxBottom + 3] === 255) borderPixels.push([data[idxBottom], data[idxBottom+1], data[idxBottom+2]]);
                }
                 for(let y = 1; y < height - 1; y+= sampleDist) { // Avoid corners already sampled
                    let idxLeft = (y * width + 0) * 4;
                    let idxRight = (y * width + (width - 1)) * 4;
                     if(data[idxLeft + 3] === 255) borderPixels.push([data[idxLeft], data[idxLeft+1], data[idxLeft+2]]);
                     if(data[idxRight + 3] === 255) borderPixels.push([data[idxRight], data[idxRight+1], data[idxRight+2]]);
                 }


                if (borderPixels.length < 5) { // If very few border pixels, sample all opaque pixels
                    console.warn("Few border pixels found, sampling all opaque pixels for background color.");
                    const allOpaquePixels = [];
                     for (let i = 0; i < data.length; i += 4) {
                         if (data[i+3] === 255) {
                            allOpaquePixels.push([data[i], data[i+1], data[i+2]]);
                         }
                     }
                     if(allOpaquePixels.length === 0) return { r: 255, g: 255, b: 255 }; // Default white if truly empty/transparent
                     return kMeansClustering(allOpaquePixels, 2); // Use k=2 for potentially bimodal (foreground/background)
                }

                // Use k-means on border pixels, k=2 is often good for border analysis
                return kMeansClustering(borderPixels, 2);

            } catch (error) {
                console.error('Error in getBackgroundColor:', error);
                return { r: 255, g: 255, b: 255 }; // Default white on error
            }
        }


        function fillTransparentBackground(ctx, width, height, color) {
            if (!color) return;
            try {
                // Get image data only once
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                const r = color.r, g = color.g, b = color.b;

                // Create a temporary canvas to draw the fill color
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');

                // Fill the temp canvas with the target color
                tempCtx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                tempCtx.fillRect(0, 0, width, height);

                // Draw the original image data *over* the fill color
                // This preserves opaque pixels and fills only transparent/semi-transparent ones
                tempCtx.putImageData(imageData, 0, 0);

                 // Now, draw the result back onto the original context
                 // Use globalCompositeOperation 'destination-over' to draw the fill *behind* existing pixels
                 // This is another way to think about it:
                 ctx.globalCompositeOperation = 'destination-over';
                 ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                 ctx.fillRect(0,0,width,height);
                 ctx.globalCompositeOperation = 'source-over'; // Reset composite operation


                /* // Original pixel manipulation method (can be slower)
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] < 255) { // If not fully opaque
                        // Blend with background color? Or just replace? Replacing is simpler here.
                        data[i] = r;
                        data[i + 1] = g;
                        data[i + 2] = b;
                        data[i + 3] = 255; // Make it fully opaque
                    }
                }
                ctx.putImageData(imageData, 0, 0);
                */
            } catch (error) { console.error('Error in fillTransparentBackground:', error); }
        }


        function removeBackground(ctx, width, height, backgroundColor) {
            if (!backgroundColor) return;
            try {
                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                // Increased tolerance slightly, adjust based on image types
                const tolerance = 70;
                const toleranceSq = tolerance * tolerance;
                const r = backgroundColor.r, g = backgroundColor.g, b = backgroundColor.b;

                for (let i = 0; i < data.length; i += 4) {
                    // Check alpha first - no need to process fully transparent pixels
                    if (data[i + 3] > 0) {
                        const colorDistanceSq = (data[i]-r)**2 + (data[i+1]-g)**2 + (data[i+2]-b)**2;
                        // Check if distance is within tolerance
                        if (colorDistanceSq < toleranceSq) {
                             data[i + 3] = 0; // Make transparent
                        }
                         // Optional: Feathering edge (more complex, adds gradient alpha)
                         // else if (colorDistanceSq < (tolerance + feather) * (tolerance + feather)) {
                         //     data[i + 3] = Math.max(0, data[i + 3] * (1 - (colorDistanceSq - toleranceSq) / ((tolerance + feather)* (tolerance + feather) - toleranceSq)));
                         // }
                    }
                }
                ctx.putImageData(imageData, 0, 0);
            } catch (error) { console.error('Error in removeBackground:', error); }
        }

    </script>
</body>
</html>
